template<typename T>
now we told the compiler that there will be a template clalled T that
can be any type...
Example:
T const*  max(T const& x, T const& y)
{
    return ((x >= y) ? x : y);
}
int a = -32;
int b = 42;
std::cout << max<int>(a, b); std::endl;  //Explicit initiation
std::cout << max(a, b) << std::endl;

What are temolate and why we have them in our  code :
------------------------------------------------------

-> the bad old days - Reuse with Cut-N-Paste
(Generic Programming)
Generic programming is a style of computer programming in which 
algorithms are written in terms of types to-be-specified-later 
that are then instantiated when needed for specific types provided
as parameters. This approach, pioneered by ML in 1973,[1][2] 
permits writing common functions or types that differ only in 
the set of types on which they operate when used, thus reducing 
duplication.

C++ supports generic Programming with templates
-------------------------------------------------
TEMPLATE CATEGORIES :

1- Function Templates:
    -> it is like  a recipe for a fucntion
2- Class Templates
    -> recipe for making classes.
3- Member Function Templates:
    -> recipe for making member functions of t parameter is the address of an array.
• The second one is the length of the array.
• The third one is a function that will be call on every element of the array.
Turn in a main.cpp file that contains your tests. Provide enough code to generate a
test executable.
Your iter function template mua classes

Template Fundamentals:
----------------------
1 -Template terminology:
-> the standard treats terms thing template consistently
    -> template : is the noun, indicating a parametrized description.
    -> thing is an agdective, specifying the family of things being parametrized.

so we have :
    this kind of template                  ..is a parametrized description
                                                of a family of ...
        -class template                         - classes
        -func template                          - functions
        -member func template                   - member functions
        -alias template                         - type alias
        -variable template                      - variables
        -lambda template                        - lambda functions

Translation Units:
---------------------------
in c++, translation is performed in nine well-defined stages : 

 * phase 1 to phase 6 perform lexical analysis
    (thes are pre-processing)
    (the output of phase 6 is a translation unit)

 * A translation unit is defined as
    -> a source file
    -> plus all the headers and source files included via #inlcude directive.
    -> minus any source lines skipped by conditional pre-processing directives (#ifdef)
    -> and all macros expanded

 * Phases 7 and 8 perform syntax analysis, semantic analysis, and codegen
    -> these are what we refer to as compilation
    -> Templates are parsed in Phase 7
    -> Template are instantiated in Phase 8.
    -> the output is called a tranlated translation unit(in other words obj code).

 * Phase 9 performs program image creation
    -> this is what we usually think of as linking.
    -> the output is an executable image.

Declaration and Definitions :
-------------------------------
An entity is very important it is something that we give a name to inside our program
    -> value
    -> object
    -> reference
    -> function
    -> class member
    -> type
    -> template
    -> template specialization
Entity are important cause we gave them names...
A name:
 is the use of an identifier that denotes an entity or label it 
    -> every name that denotes an entity is introduced by a Declaration
A Declaration:
introduces one or more names into a translation unit
    -> a Declaration may also re-introduce a name into a translition unit
A Definition:
is a Declaration that fully defines the entitt parameter is the address of an array.
• The second one is the length of the array.
• The third one is a function that will be call on every element of the array.
Turn in a main.cpp file that contains your tests. Provide enough code to generate a
test executable.
Your iter function template muy being introduced

A variable:
is an entity introduced by the Declaration of an object
    -> or of a reference other than a non-static data member

Every Declaration is also a Definition, unless:
-> it is a function declaration without a corresponding Definition of the body.
-> it is a parameter declaration in a function declaration that is not a Definition.
-> it is a declaration of a class name without a corresponding Definition.
-> it is a template parameter.
-> it is a typedef declaration.
-> it is using declaration.
-> it contains the extern specifier.
examples:

Declaration                                    Definitions
-----------------                             ----------------
extern int a;                                extern int a = 0;
extern const int c;                         extern const int c = 37;
int f(int);                                 int f(int)
                                            {
                                                return x + 1;
                                            }
class Foo;                                  class Foo
                                            {
                                                int mval;
                                            public:
                                                Foo(int x) : mval(x) {}
                                            }

typedef int Int;                            // no Definition because they are type aliases

template<class T>
T const& max(T const& a, T const& b); // declaration of function template max

template<class T>
T const& max(T const& a, T const& b) // Definition of function template max
{
    return ((a > b) ? a : b);
}

template<class T1, class T2>
struct pair;                    // declaration of a class template

template<class T1, class T2>
struct pair                     // Definition of a class template
{
    T1  first;
    T2  second;
    ...
}

The One-Definition Rule (ODR)
-----------------------------
a given translation unit can contain exectly one Definition multiple declarations is okay
but only one Definition

For an inline variable or an inline function, a definition is required in every
translation unit that uses it.
 
Templates parameters and template arguments:
--------------------------------------------
// Definition of a class template                       
template<class T1, class T2>
struct pair                                         
{
    T1  first;
    T2  second;
    ...
}

template<class T>
T const& max(T const& a, T const& b)
{...}

ChatGPT Informations for templaes:
----------------------------------
Absolutely! Let's break down that statement into simpler terms:

**Templates are compiled when instantiated with specific types:** 
Imagine a template as a blueprint for creating functions or classes. 
When you use this blueprint to make an actual function or class with a 
specific data type, that's called instantiation. It's like using a cookie-cutter 
to make cookies of different shapes. The template is the cookie-cutter, 
and when you use it, you're making cookies of different types.

**Placing them in header files ensures that the compiler can see the definitions 
at the point of instantiation:** Think of the compiler as a builder. 
When you use a template to create a function or class, the builder (compiler) 
needs to know how to build it. The builder looks at the template's design (definition) 
to build the actual thing (function or class) with the specific type.

If you put the template's design (definition) in a different place, like a separate file, 
the builder might not know how to build it when it's needed. But if you put the template's 
design in a place where the builder can easily find it, like a header file, the builder 
can quickly grab the design and build the thing exactly when you need it.

So, putting templates in header files is like keeping the blueprints where the builder 
can quickly access them to create the right things at the right time!

The template<typename T> line is used to declare the beginning of a template definition block

Function Overloading :
-------------------------
overloading doesn't spare the effort of writing nearly identical code for each nearly identical functions
but function templates do.

Function template Informations from (Dan Saks - CppCon 2019):
--------------------------------------------------------------
is not a function it is just a tool to print a function 
The art of generating a function definition from a template is called template instantiation.
A function definition generated from a function template is an instantiated function.

once we call that function (swap<int>(i,j)) the comiler automatically instantiates a definition for a 
function declared as void swap<int>(int &a, int &b);
when doing this call the compiler use it as a declaration for that fucntion and create
a function for that.

In case of a duplicate declaration of the same data types but with different values the
compiler does not instantiate multiple functions it rather instantiate a single function for 
all the calls of that type.

Very important:
----------------
withing the scope of the class template rational<T>, you can usually refer to the class 
name as either:
-> rational 
-> rational<T>

--> that is, the <T> after the class template name is optional
--but only in the scope of the class template

for example you can write the class definition as following:

template <typename T>
class rational
{
public:
    rational();
    rational(T n);
    rational (T n, T d);
    rational& operator+= (rational const& ro);
    .........
}

or you can write it like this :
template <typename T>
class rational
{
public:
    rational<T>();
    rational<T>(T n);
    rational<T> (T n, T d);
    rational<T>& operator+= (rational<T> const& ro);
    .........
}

           (reenter the class scope here)
rational<T>::operator+=(rational const& ro) {}
                                <T> here is optional (we are inside the scope ::)                
        (<T> is not optional outside class template scope)

// why it does not check errors:
----------------------------------
in the initial load that the compiler do to the template it does not do much
it just load it in a symbole table to use it later once we instantiate it 
and for that it does not do much to errors checking ...
is there a way we can check for errors early to help us not compile with errors
well ::
a compiler processses each template definition in two phases: 
1 -> the 1st phase occurs when the comiler parses the template declaration
    -> this happens just once for each template
2 -> the 2end phase occurs when the compiler instantiate the template for 
    a particular combination of templae arguments
    -> this happens at each instantiation.

Template specialization: 
--------------------------
when you subsitute a specific combination of arguments for a template's parameters
you get a specialization.
    -> the real meaning of a specialization is when u take a template, and take a combination
    of arguments and pair them together tha's a specialization.
example:
    swap T is a generalization of swap but swap int is a specialization that swap integers
                                           swap float is a specialization that swap float

syntax : 
    template_name <argument-list>
it is refered to by a template-id
for example:
    swap<int> is template id it names the specialization of the swap template that swaps integers.

